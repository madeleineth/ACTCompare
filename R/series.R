# From ACTCompare, (c) 2010 Madeleine Thompson
# $Id: series.R 1851 2010-10-21 14:03:31Z mthompson $

# Define some series for use with act.method.compare(), exported
# by way of generate.act.series().  Most series are defined by a
# function that simulates that series for a particular length.
# These functions return lists with elements representing the series,
# true act, and series name.

# AR(1) process with coefficient 0.98, true ACT computed analytically.

ar1 <- function(series.length) {
  ar1.rho <- 0.98
  ar1.act <- (1-ar1.rho^2)/(1-ar1.rho)^2
  list(series=arima.sim(list(ar=ar1.rho), series.length), act=ar1.act,
       name='AR(1)')
}

# AR(2) process with roots at 1+/-0.1i, true ACT computed analytically.

ar2 <- function(series.length) {
  r1 <- -1+0.1i                              # first root
  pi1 <- Re(-(r1+Conj(r1))/(r1*Conj(r1)))    # first lag coefficient
  pi2 <- Re(-1/(r1*Conj(r1)))                # second lag coefficient

  # compute ACT with Wei (2006) equation 12.2.8b (p. 275).

  ar2.act <- (1-sum(ARMAacf(ar=c(pi1,pi2))[2:3]*c(pi1,pi2)))/(-1+pi1+pi2)^2

  list(series=arima.sim(list(ar=c(pi1,pi2)), series.length), act=ar2.act,
       name='AR(2)')
}

# AR(1) process with ARCH(1) errors, see Wei p. 368.  True ACT
# computed analytically.  Innovations are distributed as:
#
#  n_t ~ N(0, 0.01 + 0.99 n_{t-1}^2)

ar1arch1 <- function(series.length) {
  theta0 <- 0.01
  theta1 <- 0.99
  pi1 <- 0.98
  n <- 0

  y <- numeric(series.length)
  for (t in 2:series.length) {
    n <- rnorm(1, sd=sqrt(theta0+theta1*n^2))
    y[t] <- pi1 * y[t-1] + n
  }

  ar1arch1.act <- (1-pi1^2)/(1-pi1)^2
  list(series=y, act=ar1arch1.act, name='AR(1)-ARCH(1)')
}

# Metropolis draws from a Gaussian.  True ACT computed empirically.
# The Metropolis proposals and target distribution are both mean zero
# with unit variance.

met.gauss <- function(series.length) {
  S <- univar.metropolis.sample(make.gaussian(0), 0, series.length)
  list(series=S$X, act=8.2, name='Met-Gauss')
}

# Badly-tuned ARMS draws from a mixture of two Gaussians.  The true
# ACT was determined empirically from a hundred 100,000-sample chains.
# The result is consistent with the number of transitions between the
# two modes.  The initial state, x=0, is such that the initial envelope
# each iteration does not cover the second mode.

arms.bimodal <- function(series.length) {
  ds <- make.1d.mixture(8)
  S <- arms.sample(ds, 0, series.length)
  list(series=S$X-ds$mean, act=210, name='ARMS-Bimodal')
}

# A SamplerCompare distribution object for a univariate mixture of
# two Gaussians, taken from ExtraCompare.  Used by arms.bimodal.  The
# first mixture component is a standard Gaussian, the second is a
# Gaussian with unit variance and mean d.

make.1d.mixture <- function(d=6) {
  L <- function(x) log(exp(-x^2/2) + exp(-(x-d)^2/2))
  dL <- function(x) ( (exp(-x^2/2)*(-x)+exp(-(x-d)^2/2)*(d-x)) /
                        (exp(-x^2/2) + exp(-(x-d)^2/2)) )
  name <- sprintf('Gaussian Mixture', d)
  mix.ds <- make.dist(1, name, log.density=L, grad.log.density=dL, mean=d/2)
  return(mix.ds)
}

# A chain generated by using slice sampling with stepping out with
# a tuning parameter of about three on Gelman et al's "eight schools"
# example.  The "true" ACT is the median of the union of the AR,
# Batch, and ICS estimates associated with fifty 100,000-sample chains.
# I estimate it to be within 20 of the asymptotic limit.  I set the seed
# to 17 because I know this particular seed generates a difficult series.

stepout.log.var <- function(series.length) {
  set.seed(17)
  S <- stepout.slice.sample(schools.dist, schools.dist$mean,
                            series.length, tuning=sqrt(10))
  list(series=S$X[,2], act=190, name='Stepout-Log-Var')
}

# Collect and standardize series.  With a series length of 1e6,
# this takes about two hours on a single fast core (by 2010 standards).

generate.act.series <- function(series.length=1e6) {

  # Generate all series.

  set.seed(17)
  all.series <- list(ar1(series.length),                # very fast
                     ar2(series.length),                # very fast
                     ar1arch1(series.length),           # fast
                     met.gauss(series.length),          # fast
                     arms.bimodal(series.length),       # slow
                     stepout.log.var(series.length))    # slow

  # Name series; not necessary, but convenient.

  names(all.series) <- lapply(all.series, function(e) e$name)

  # Generate the seventh series by exponentiating 'Stepout-Log-Var'.
  # The true ACT was determined empirically.

  stepout.var <- list(series=exp(all.series[['Stepout-Log-Var']]$series),
                      act=107, name='Stepout-Var')
  all.series[[stepout.var$name]] <- stepout.var

  # De-mean each series and coerce ACTs to reals.

  for (i in 1:length(all.series)) {
    y <- all.series[[i]]$series
    all.series[[i]]$series <- y - mean(y)

    stopifnot(Im(all.series[[i]]$act)==0)
    all.series[[i]]$act <- Re(all.series[[i]]$act)
  }
  return(all.series)
}
